shared-lib/                      # repo root
‚îú‚îÄ‚îÄ vars/
‚îÇ   ‚îú‚îÄ‚îÄ injectSecrets.groovy     # your custom step
‚îÇ   ‚îî‚îÄ‚îÄ (other library steps if needed)
--------------------------------------------------------
vars/injectSecrets.groovy

def call(Map args) {
    def currentKeyVault = args.currentKeyVault
    def gradleFile      = args.gradleFile
    def appPropsFile    = args.appPropsFile

    echo "Logging into Azure..."
    sh 'az login --identity'

    echo "Fetching secrets from Azure Key Vault..."
    def clientId = sh(script: "az keyvault secret show --vault-name ${currentKeyVault} --name keyvault-client-id --query value -o tsv", returnStdout: true).trim()
    def clientSecret = sh(script: "az keyvault secret show --vault-name ${currentKeyVault} --name keyvault-client-secret --query value -o tsv", returnStdout: true).trim()
    def tenantId = sh(script: "az keyvault secret show --vault-name ${currentKeyVault} --name keyvault-tenant-id --query value -o tsv", returnStdout: true).trim()

    echo "üõ†Ô∏è Replacing placeholders in ${gradleFile} and ${appPropsFile}..."

    sh """
        sed -i 's|KEYVAULT_CLIENT_ID|${clientId}|' ${gradleFile}
        sed -i 's|KEYVAULT_CLIENT_SECRET|${clientSecret}|' ${gradleFile}
        sed -i 's|KEYVAULT_TENANT_ID|${tenantId}|' ${gradleFile}

        sed -i 's|KEYVAULT_CLIENT_ID|${clientId}|' ${appPropsFile}
        sed -i 's|KEYVAULT_CLIENT_SECRET|${clientSecret}|' ${appPropsFile}
        sed -i 's|KEYVAULT_TENANT_ID|${tenantId}|' ${appPropsFile}
    """
}
---------------
Jenkinsfile


@Library('shared-lib') _

def buildUser = 'Unknown'

def branchMap = [:]
def yamlMap = [:]
def clusterMap = [:]
def currentBranch = ''
def currentYaml = ''
def currentCluster = ''
def imageTag = ''
def gradleFile = ''
def appPropsFile = ''
def currentKeyVault = ''

pipeline {
    agent any

    tools {
        gradle 'Gradle'
    }

    options {
        buildDiscarder(logRotator(daysToKeepStr: '60'))
    }

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['Dev', 'QA', 'UAT'],
            description: 'Select the target environment'
        )

        choice(
            name: 'SERVICE_NAME',
            choices: [
                'cacheservice', 'cloudgateway', 'documentmanagementservice',
                'fileingestionservice', 'internationservice', 'mailservice',
                'netsuiteintegrationservices', 'participantservice',
                'playlistandtitlemanagement', 'searchservice', 'securityservice',
                'serviceregistry'
            ],
            description: 'Select the backend service to deploy'
        )
    }

    environment {
        USERNAME = credentials('ACRUSERNAME')
        PASSWD = credentials('ACRPASSWD')
        RESOURCE_GROUP = 'CODA_RG'
    }

    stages {

        stage('Init') {
            steps {
                script {
                    wrap([$class: 'BuildUser']) {
                        buildUser = env.BUILD_USER ?: 'Unknown'
                    }

                    branchMap = [
                        Dev: 'DEV', QA: 'QA', UAT: 'release/UAT'
                    ]
                    yamlMap = [
                        Dev: "${params.SERVICE_NAME}-dev-deployment.yml",
                        QA: "${params.SERVICE_NAME}-qa-deployment.yml",
                        UAT: "${params.SERVICE_NAME}-uat-deployment.yml"
                    ]
                    clusterMap = [
                        Dev: 'DevFundCluster',
                        QA: 'DevFundCluster',
                        UAT: 'CODAUATCluster'
                    ]

                    // KeyVault mapping (adjust names as per your envs)
                    def keyVaultMap = [
                        Dev: 'DevKeyVault',
                        QA: 'QaKeyVault',
                        UAT: 'UatKeyVault'
                    ]

                    def envMap = [
                        Dev: 'dev',
                        QA: 'qa',
                        UAT: 'uat'
                    ]

                    currentBranch   = branchMap[params.ENVIRONMENT]
                    currentYaml     = yamlMap[params.ENVIRONMENT]
                    currentCluster  = clusterMap[params.ENVIRONMENT]
                    currentKeyVault = keyVaultMap[params.ENVIRONMENT]
                    def suffix      = envMap[params.ENVIRONMENT]

                    gradleFile   = "gradle-${suffix}.properties"
                    appPropsFile = "src/main/resources/application-${suffix}.properties"
                    imageTag     = "${params.SERVICE_NAME}-${params.ENVIRONMENT}-${env.BUILD_NUMBER}"

                    echo """
                    ==============================================================
                             BACKEND CONFIG DETAILS:
                    --------------------------------------------------------------
                            ‚úÖ Service Name     : ${params.SERVICE_NAME}
                            üåç Environment      : ${params.ENVIRONMENT}
                            üåø Git Branch       : ${currentBranch}
                            ‚ò∏Ô∏è AKS Cluster      : ${currentCluster}
                            üîê Key Vault        : ${currentKeyVault}
                            üìÑ Gradle Properties: ${gradleFile}
                            üìÑ App Properties   : ${appPropsFile}
                            üê≥ Docker Image Tag : ${imageTag}
                    ==============================================================
                    """
                }
            }
        }

        stage('Checkout Code') {
            steps {
                cleanWs()
                script {
                    git branch: currentBranch,
                        credentialsId: 'bitbucket',
                        url: "git@bitbucket.org:asaiprdf/${params.SERVICE_NAME}.git"
                }
            }
        }

        stage('Inject Secrets into Gradle & App Properties') {
            steps {
                script {
                    injectSecrets(
                        currentKeyVault: currentKeyVault,
                        gradleFile: gradleFile,
                        appPropsFile: appPropsFile
                    )
                }
            }
        }

        stage('Show Final Properties') {
            steps {
                script {
                    echo "\n Final content of gradle file:"
                    sh "cat ${gradleFile}"

                    echo "\nFinal content of application properties file:"
                    sh "cat ${appPropsFile}"
                }
            }
        }

        stage('Build Service') {
            steps {
                script {
                    sh "gradle wrapper"
                    sh "sudo chmod 755 gradlew"
                    sh "./gradlew clean build --no-daemon"
                }
            }
        }

        stage('Notify for Approval') {
            when {
                expression { params.ENVIRONMENT == 'QA' || params.ENVIRONMENT == 'UAT' }
            }
            steps {
                script {
                    notifyTeam(
                        env: params.ENVIRONMENT,
                        serviceName: params.SERVICE_NAME,
                        buildNumber: env.BUILD_NUMBER,
                        buildUrl: env.BUILD_URL,
                        type: 'approval',
                        triggeredBy: buildUser
                    )

                    def approvers = ['vbboya@afmsagaftrafund.org']
                    timeout(time: 30, unit: 'MINUTES') {
                        input(
                            message: "üö¶ Approve deployment of '${params.SERVICE_NAME}' to '${params.ENVIRONMENT}'?",
                            ok: "Approve",
                            submitter: approvers.join(',')
                        )
                    }
                }
            }
        }

        stage('Dockerize') {
            steps {
                script {
                    sh "mkdir -p $WORKSPACE/certificate"
                    sh "sudo cp /home/jenkinsadmin/certificate/certificate.crt $WORKSPACE/certificate"
                    sh "sudo docker build --network=host -t codaregistry.azurecr.io/${params.SERVICE_NAME}:${imageTag} ."
                    sh "echo $PASSWD | docker login codaregistry.azurecr.io -u $USERNAME --password-stdin"
                    sh "sudo docker push codaregistry.azurecr.io/${params.SERVICE_NAME}:${imageTag}"
                }
            }
        }

        stage('Deploy') {
            steps {
                script {
                    sh "az login --identity"
                    sh "az aks get-credentials --name ${currentCluster} --resource-group ${RESOURCE_GROUP} --overwrite-existing"
                    sh "sed -i 's/ENVIRONMENT-BUILD_NUMBER/${imageTag}/' ${currentYaml}"
                    sh "kubectl apply -f ${currentYaml}"
                }
            }
        }

        stage('Notify Success') {
            steps {
                script {
                    notifyTeam(
                        env: params.ENVIRONMENT,
                        serviceName: params.SERVICE_NAME,
                        buildNumber: env.BUILD_NUMBER,
                        buildUrl: env.BUILD_URL,
                        type: 'success',
                        triggeredBy: buildUser
                    )
                }
            }
        }

        stage('Clean Up') {
            steps {
                sh 'sudo docker system prune --all --volumes -f'
                cleanWs()
            }
        }
    }

    post {
        failure {
            script {
                notifyTeam(
                    env: params.ENVIRONMENT,
                    serviceName: params.SERVICE_NAME,
                    buildNumber: env.BUILD_NUMBER,
                    buildUrl: env.BUILD_URL,
                    type: 'failure',
                    triggeredBy: buildUser
                )
            }
        }
    }
}


 










